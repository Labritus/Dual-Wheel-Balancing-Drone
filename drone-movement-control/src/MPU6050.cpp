#include "MPU6050.hpp"
#include "EXTI.hpp"
#include "delay.hpp"
#include "math.h"
#include <string.h>
float      MPU6050_Quat[4]    = {0, 0, 0, 0};
uint32_t   MPU6050_StepCount  = 0;
uint32_t   MPU6050_WalkTime   = 0;

// Sensor data
int16_t accel[3], gyro[3];
MPU6050_DMP_Data MPU6050Data;
float Pitch, Roll, Yaw;

// Gyroscope zero offset
int16_t gyro_offset[3] = {0};

// Define static constant member variables
// These static member variables must be defined outside the class

const uint8_t MPU6050::dmpMemory[] = {  /* bank # 0 */
    0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x02, 0x00, 0x03, 0x00, 0x00,
    0x00, 0x65, 0x00, 0x54, 0xff, 0xef, 0x00, 0x00, 0xfa, 0x80, 0x00, 0x0b, 0x12, 0x82, 0x00, 0x01,
    0x03, 0x0c, 0x30, 0xc3, 0x0e, 0x8c, 0x8c, 0xe9, 0x14, 0xd5, 0x40, 0x02, 0x13, 0x71, 0x0f, 0x8e,
    0x38, 0x83, 0xf8, 0x83, 0x30, 0x00, 0xf8, 0x83, 0x25, 0x8e, 0xf8, 0x83, 0x30, 0x00, 0xf8, 0x83,
    0xff, 0xff, 0xff, 0xff, 0x0f, 0xfe, 0xa9, 0xd6, 0x24, 0x00, 0x04, 0x00, 0x1a, 0x82, 0x79, 0xa1,
    0x00, 0x00, 0x00, 0x3c, 0xff, 0xff, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x38, 0x83, 0x6f, 0xa2,
    0x00, 0x3e, 0x03, 0x30, 0x40, 0x00, 0x00, 0x00, 0x02, 0xca, 0xe3, 0x09, 0x3e, 0x80, 0x00, 0x00,
    0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00,
    0x00, 0x0c, 0x00, 0x00, 0x00, 0x0c, 0x18, 0x6e, 0x00, 0x00, 0x06, 0x92, 0x0a, 0x16, 0xc0, 0xdf,
    0xff, 0xff, 0x02, 0x56, 0xfd, 0x8c, 0xd3, 0x77, 0xff, 0xe1, 0xc4, 0x96, 0xe0, 0xc5, 0xbe, 0xaa,
    0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x0b, 0x2b, 0x00, 0x00, 0x16, 0x57, 0x00, 0x00, 0x03, 0x59,
    0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1d, 0xfa, 0x00, 0x02, 0x6c, 0x1d, 0x00, 0x00, 0x00, 0x00,
    0x3f, 0xff, 0xdf, 0xeb, 0x00, 0x3e, 0xb3, 0xb6, 0x00, 0x0d, 0x22, 0x78, 0x00, 0x00, 0x2f, 0x3c,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0x42, 0xb5, 0x00, 0x00, 0x39, 0xa2, 0x00, 0x00, 0xb3, 0x65,
    0xd9, 0x0e, 0x9f, 0xc9, 0x1d, 0xcf, 0x4c, 0x34, 0x30, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00,
    0x3b, 0xb6, 0x7a, 0xe8, 0x00, 0x64, 0x00, 0x00, 0x00, 0xc8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    /* bank # 1 */
    0x10, 0x00, 0x00, 0x00, 0x10, 0x00, 0xfa, 0x92, 0x10, 0x00, 0x22, 0x5e, 0x00, 0x0d, 0x22, 0x9f,
    0x00, 0x01, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0xff, 0x46, 0x00, 0x00, 0x63, 0xd4, 0x00, 0x00,
    0x10, 0x00, 0x00, 0x00, 0x04, 0xd6, 0x00, 0x00, 0x04, 0xcc, 0x00, 0x00, 0x04, 0xcc, 0x00, 0x00,
    0x00, 0x00, 0x10, 0x72, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x06, 0x00, 0x02, 0x00, 0x05, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x05, 0x00, 0x64, 0x00, 0x20, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x03, 0x00,
    0x00, 0x00, 0x00, 0x32, 0xf8, 0x98, 0x00, 0x00, 0xff, 0x65, 0x00, 0x00, 0x83, 0x0f, 0x00, 0x00,
    0xff, 0x9b, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00,
    0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0xb2, 0x6a, 0x00, 0x02, 0x00, 0x00,
    0x00, 0x01, 0xfb, 0x83, 0x00, 0x68, 0x00, 0x00, 0x00, 0xd9, 0xfc, 0x00, 0x7c, 0xf1, 0xff, 0x83,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x65, 0x00, 0x00, 0x00, 0x64, 0x03, 0xe8, 0x00, 0x64, 0x00, 0x28,
    0x00, 0x00, 0x00, 0x25, 0x00, 0x00, 0x00, 0x00, 0x16, 0xa0, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00,
    0x00, 0x00, 0x10, 0x00, 0x00, 0x2f, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf4, 0x00, 0x00, 0x10, 0x00,
    /* bank # 2 */
    0x00, 0x28, 0x00, 0x00, 0xff, 0xff, 0x45, 0x81, 0xff, 0xff, 0xfa, 0x72, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x44, 0x00, 0x05, 0x00, 0x05, 0xba, 0xc6, 0x00, 0x47, 0x78, 0xa2,
    0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x14,
    0x00, 0x00, 0x25, 0x4d, 0x00, 0x2f, 0x70, 0x6d, 0x00, 0x00, 0x05, 0xae, 0x00, 0x0c, 0x02, 0xd0,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x1b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x64, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x1b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x0e,
    0x00, 0x00, 0x0a, 0xc7, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x32, 0xff, 0xff, 0xff, 0x9c,
    0x00, 0x00, 0x0b, 0x2b, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x64,
    0xff, 0xe5, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    /* bank # 3 */
    0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x01, 0x80, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x24, 0x26, 0xd3,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x10, 0x00, 0x96, 0x00, 0x3c,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x0c, 0x0a, 0x4e, 0x68, 0xcd, 0xcf, 0x77, 0x09, 0x50, 0x16, 0x67, 0x59, 0xc6, 0x19, 0xce, 0x82,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0xd7, 0x84, 0x00, 0x03, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc7, 0x93, 0x8f, 0x9d, 0x1e, 0x1b, 0x1c, 0x19,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x03, 0x18, 0x85, 0x00, 0x00, 0x40, 0x00,
    0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x67, 0x7d, 0xdf, 0x7e, 0x72, 0x90, 0x2e, 0x55, 0x4c, 0xf6, 0xe6, 0x88,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    /* bank # 4 */
    0xd8, 0xdc, 0xb4, 0xb8, 0xb0, 0xd8, 0xb9, 0xab, 0xf3, 0xf8, 0xfa, 0xb3, 0xb7, 0xbb, 0x8e, 0x9e,
    0xae, 0xf1, 0x32, 0xf5, 0x1b, 0xf1, 0xb4, 0xb8, 0xb0, 0x80, 0x97, 0xf1, 0xa9, 0xdf, 0xdf, 0xdf,
    0xaa, 0xdf, 0xdf, 0xdf, 0xf2, 0xaa, 0xc5, 0xcd, 0xc7, 0xa9, 0x0c, 0xc9, 0x2c, 0x97, 0xf1, 0xa9,
    0x89, 0x26, 0x46, 0x66, 0xb2, 0x89, 0x99, 0xa9, 0x2d, 0x55, 0x7d, 0xb0, 0xb0, 0x8a, 0xa8, 0x96,
    0x36, 0x56, 0x76, 0xf1, 0xba, 0xa3, 0xb4, 0xb2, 0x80, 0xc0, 0xb8, 0xa8, 0x97, 0x11, 0xb2, 0x83,
    0x98, 0xba, 0xa3, 0xf0, 0x24, 0x08, 0x44, 0x10, 0x64, 0x18, 0xb2, 0xb9, 0xb4, 0x98, 0x83, 0xf1,
    0xa3, 0x29, 0x55, 0x7d, 0xba, 0xb5, 0xb1, 0xa3, 0x83, 0x93, 0xf0, 0x00, 0x28, 0x50, 0xf5, 0xb2,
    0xb6, 0xaa, 0x83, 0x93, 0x28, 0x54, 0x7c, 0xf1, 0xb9, 0xa3, 0x82, 0x93, 0x61, 0xba, 0xa2, 0xda,
    0xde, 0xdf, 0xdb, 0x81, 0x9a, 0xb9, 0xae, 0xf5, 0x60, 0x68, 0x70, 0xf1, 0xda, 0xba, 0xa2, 0xdf,
    0xd9, 0xba, 0xa2, 0xfa, 0xb9, 0xa3, 0x82, 0x92, 0xdb, 0x31, 0xba, 0xa2, 0xd9, 0xba, 0xa2, 0xf8,
    0xdf, 0x85, 0xa4, 0xd0, 0xc1, 0xbb, 0xad, 0x83, 0xc2, 0xc5, 0xc7, 0xb8, 0xa2, 0xdf, 0xdf, 0xdf,
    0xba, 0xa0, 0xdf, 0xdf, 0xdf, 0xd8, 0xd8, 0xf1, 0xb8, 0xaa, 0xb3, 0x8d, 0xb4, 0x98, 0x0d, 0x35,
    0x5d, 0xb2, 0xb6, 0xba, 0xaf, 0x8c, 0x96, 0x19, 0x8f, 0x9f, 0xa7, 0x0e, 0x16, 0x1e, 0xb4, 0x9a,
    0xb8, 0xaa, 0x87, 0x2c, 0x54, 0x7c, 0xba, 0xa4, 0xb0, 0x8a, 0xb6, 0x91, 0x32, 0x56, 0x76, 0xb2,
    0x84, 0x94, 0xa4, 0xc8, 0x08, 0xcd, 0xd8, 0xb8, 0xb4, 0xb0, 0xf1, 0x99, 0x82, 0xa8, 0x2d, 0x55,
    0x7d, 0x98, 0xa8, 0x0e, 0x16, 0x1e, 0xa2, 0x2c, 0x54, 0x7c, 0x92, 0xa4, 0xf0, 0x2c, 0x50, 0x78,
    /* bank # 5 */
    0xf1, 0x84, 0xa8, 0x98, 0xc4, 0xcd, 0xfc, 0xd8, 0x0d, 0xdb, 0xa8, 0xfc, 0x2d, 0xf3, 0xd9, 0xba,
    0xa6, 0xf8, 0xda, 0xba, 0xa6, 0xde, 0xd8, 0xba, 0xb2, 0xb6, 0x86, 0x96, 0xa6, 0xd0, 0xf3, 0xc8,
    0x41, 0xda, 0xa6, 0xc8, 0xf8, 0xd8, 0xb0, 0xb4, 0xb8, 0x82, 0xa8, 0x92, 0xf5, 0x2c, 0x54, 0x88,
    0x98, 0xf1, 0x35, 0xd9, 0xf4, 0x18, 0xd8, 0xf1, 0xa2, 0xd0, 0xf8, 0xf9, 0xa8, 0x84, 0xd9, 0xc7,
    0xdf, 0xf8, 0xf8, 0x83, 0xc5, 0xda, 0xdf, 0x69, 0xdf, 0x83, 0xc1, 0xd8, 0xf4, 0x01, 0x14, 0xf1,
    0xa8, 0x82, 0x4e, 0xa8, 0x84, 0xf3, 0x11, 0xd1, 0x82, 0xf5, 0xd9, 0x92, 0x28, 0x97, 0x88, 0xf1,
    0x09, 0xf4, 0x1c, 0x1c, 0xd8, 0x84, 0xa8, 0xf3, 0xc0, 0xf9, 0xd1, 0xd9, 0x97, 0x82, 0xf1, 0x29,
    0xf4, 0x0d, 0xd8, 0xf3, 0xf9, 0xf9, 0xd1, 0xd9, 0x82, 0xf4, 0xc2, 0x03, 0xd8, 0xde, 0xdf, 0x1a,
    0xd8, 0xf1, 0xa2, 0xfa, 0xf9, 0xa8, 0x84, 0x98, 0xd9, 0xc7, 0xdf, 0xf8, 0xf8, 0xf8, 0x83, 0xc7,
    0xda, 0xdf, 0x69, 0xdf, 0xf8, 0x83, 0xc3, 0xd8, 0xf4, 0x01, 0x14, 0xf1, 0x98, 0xa8, 0x82, 0x2e,
    0xa8, 0x84, 0xf3, 0x11, 0xd1, 0x82, 0xf5, 0xd9, 0x92, 0x50, 0x97, 0x88, 0xf1, 0x09, 0xf4, 0x1c,
    0xd8, 0x84, 0xa8, 0xf3, 0xc0, 0xf8, 0xf9, 0xd1, 0xd9, 0x97, 0x82, 0xf1, 0x49, 0xf4, 0x0d, 0xd8,
    0xf3, 0xf9, 0xf9, 0xd1, 0xd9, 0x82, 0xf4, 0xc4, 0x03, 0xd8, 0xde, 0xdf, 0xd8, 0xf1, 0xad, 0x88,
    0x98, 0xcc, 0xa8, 0x09, 0xf9, 0xd9, 0x82, 0x92, 0xa8, 0xf5, 0x7c, 0xf1, 0x88, 0x3a, 0xcf, 0x94,
    0x4a, 0x6e, 0x98, 0xdb, 0x69, 0x31, 0xda, 0xad, 0xf2, 0xde, 0xf9, 0xd8, 0x87, 0x95, 0xa8, 0xf2,
    0x21, 0xd1, 0xda, 0xa5, 0xf9, 0xf4, 0x17, 0xd9, 0xf1, 0xae, 0x8e, 0xd0, 0xc0, 0xc3, 0xae, 0x82,
    /* bank # 6 */
    0xc6, 0x84, 0xc3, 0xa8, 0x85, 0x95, 0xc8, 0xa5, 0x88, 0xf2, 0xc0, 0xf1, 0xf4, 0x01, 0x0e, 0xf1,
    0x8e, 0x9e, 0xa8, 0xc6, 0x3e, 0x56, 0xf5, 0x54, 0xf1, 0x88, 0x72, 0xf4, 0x01, 0x15, 0xf1, 0x98,
    0x45, 0x85, 0x6e, 0xf5, 0x8e, 0x9e, 0x04, 0x88, 0xf1, 0x42, 0x98, 0x5a, 0x8e, 0x9e, 0x06, 0x88,
    0x69, 0xf4, 0x01, 0x1c, 0xf1, 0x98, 0x1e, 0x11, 0x08, 0xd0, 0xf5, 0x04, 0xf1, 0x1e, 0x97, 0x02,
    0x02, 0x98, 0x36, 0x25, 0xdb, 0xf9, 0xd9, 0x85, 0xa5, 0xf3, 0xc1, 0xda, 0x85, 0xa5, 0xf3, 0xdf,
    0xd8, 0x85, 0x95, 0xa8, 0xf3, 0x09, 0xda, 0xa5, 0xfa, 0xd8, 0x82, 0x92, 0xa8, 0xf5, 0x78, 0xf1,
    0x88, 0x1a, 0x84, 0x9f, 0x26, 0x88, 0x98, 0x21, 0xda, 0xf4, 0x1d, 0xf3, 0xd8, 0x87, 0x9f, 0x39,
    0xd1, 0xaf, 0xd9, 0xdf, 0xdf, 0xfb, 0xf9, 0xf4, 0x0c, 0xf3, 0xd8, 0xfa, 0xd0, 0xf8, 0xda, 0xf9,
    0xf9, 0xd0, 0xdf, 0xd9, 0xf9, 0xd8, 0xf4, 0x0b, 0xd8, 0xf3, 0x87, 0x9f, 0x39, 0xd1, 0xaf, 0xd9,
    0xdf, 0xdf, 0xf4, 0x1d, 0xf3, 0xd8, 0xfa, 0xfc, 0xa8, 0x69, 0xf9, 0xf9, 0xaf, 0xd0, 0xda, 0xde,
    0xfa, 0xd9, 0xf8, 0x8f, 0x9f, 0xa8, 0xf1, 0xcc, 0xf3, 0x98, 0xdb, 0x45, 0xd9, 0xaf, 0xdf, 0xd0,
    0xf8, 0xd8, 0xf1, 0x8f, 0x9f, 0xa8, 0xca, 0xf3, 0x88, 0x09, 0xda, 0xaf, 0x8f, 0xcb, 0xf8, 0xd8,
    0xf2, 0xad, 0x97, 0x8d, 0x0c, 0xd9, 0xa5, 0xdf, 0xf9, 0xba, 0xa6, 0xf3, 0xfa, 0xf4, 0x12, 0xf2,
    0xd8, 0x95, 0x0d, 0xd1, 0xd9, 0xba, 0xa6, 0xf3, 0xfa, 0xda, 0xa5, 0xf2, 0xc1, 0xba, 0xa6, 0xf3,
    0xdf, 0xd8, 0xf1, 0xba, 0xb2, 0xb6, 0x86, 0x96, 0xa6, 0xd0, 0xca, 0xf3, 0x49, 0xda, 0xa6, 0xcb,
    0xf8, 0xd8, 0xb0, 0xb4, 0xb8, 0xd8, 0xad, 0x84, 0xf2, 0xc0, 0xdf, 0xf1, 0x8f, 0xcb, 0xc3, 0xa8,
    /* bank # 7 */
    0xb2, 0xb6, 0x86, 0x96, 0xc8, 0xc1, 0xcb, 0xc3, 0xf3, 0xb0, 0xb4, 0x88, 0x98, 0xa8, 0x21, 0xdb,
    0x71, 0x8d, 0x9d, 0x71, 0x85, 0x95, 0x21, 0xd9, 0xad, 0xf2, 0xfa, 0xd8, 0x85, 0x97, 0xa8, 0x28,
    0xd9, 0xf4, 0x08, 0xd8, 0xf2, 0x8d, 0x29, 0xda, 0xf4, 0x05, 0xd9, 0xf2, 0x85, 0xa4, 0xc2, 0xf2,
    0xd8, 0xa8, 0x8d, 0x94, 0x01, 0xd1, 0xd9, 0xf4, 0x11, 0xf2, 0xd8, 0x87, 0x21, 0xd8, 0xf4, 0x0a,
    0xd8, 0xf2, 0x84, 0x98, 0xa8, 0xc8, 0x01, 0xd1, 0xd9, 0xf4, 0x11, 0xd8, 0xf3, 0xa4, 0xc8, 0xbb,
    0xaf, 0xd0, 0xf2, 0xde, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8, 0xd8, 0xf1, 0xb8, 0xf6,
    0xb5, 0xb9, 0xb0, 0x8a, 0x95, 0xa3, 0xde, 0x3c, 0xa3, 0xd9, 0xf8, 0xd8, 0x5c, 0xa3, 0xd9, 0xf8,
    0xd8, 0x7c, 0xa3, 0xd9, 0xf8, 0xd8, 0xf8, 0xf9, 0xd1, 0xa5, 0xd9, 0xdf, 0xda, 0xfa, 0xd8, 0xb1,
    0x85, 0x30, 0xf7, 0xd9, 0xde, 0xd8, 0xf8, 0x30, 0xad
}; // Initialize to 0, actual DMP firmware data should be filled in

const uint16_t MPU6050::dmpMemorySize = sizeof(MPU6050::dmpMemory);
const uint8_t MPU6050::dmpConfig[] = {0}; 
const uint16_t MPU6050::dmpConfigSize = sizeof(MPU6050::dmpConfig);
const uint8_t MPU6050::dmpPacketSize = 42; 


uint8_t MPU6050::readByte(uint8_t regAddr)
{
    uint8_t data;
    data=IOI2C::readByteFromRegister(devAddr, regAddr);
    return data;
}


void MPU6050::writeByte(uint8_t regAddr, uint8_t data)
{
    IOI2C::writeByteToRegister(devAddr, regAddr, data);
}



void MPU6050::initialize()
{
    
    writeByte(MPU6050_RA_PWR_MGMT_1, 0x01);
    
    
    writeByte(MPU6050_RA_GYRO_CONFIG, (MPU6050_GYRO_FS_2000 << 3));
    writeByte(MPU6050_RA_ACCEL_CONFIG, (MPU6050_ACCEL_FS_2 << 3));
    
    
    writeByte(MPU6050_RA_CONFIG, 0x06); 
    
    
    writeByte(MPU6050_RA_SMPLRT_DIV, 0x00);
    
   
    writeByte(MPU6050_RA_INT_ENABLE, 0x00);
    
    
    writeByte(MPU6050_RA_INT_PIN_CFG, 0x02);
}


uint8_t MPU6050::testConnection()
{
    return (getDeviceID() == 0x68);
}


uint8_t MPU6050::getDeviceID()
{
    return readByte(MPU6050_RA_WHO_AM_I);
}

uint8_t MPU6050::getData()
{
    uint8_t buffer[14];
    if (IOI2C::readMultiBytesFromRegister(devAddr, MPU6050_RA_ACCEL_XOUT_H, 14, buffer) == 0) {
        accel[0] = (((int16_t)buffer[0]) << 8) | buffer[1];
        accel[1] = (((int16_t)buffer[2]) << 8) | buffer[3];
        accel[2] = (((int16_t)buffer[4]) << 8) | buffer[5];
        
        gyro[0] = (((int16_t)buffer[8]) << 8) | buffer[9];
        gyro[1] = (((int16_t)buffer[10]) << 8) | buffer[11];
        gyro[2] = (((int16_t)buffer[12]) << 8) | buffer[13];
        
        
        gyro[0] -= gyro_offset[0];
        gyro[1] -= gyro_offset[1];
        gyro[2] -= gyro_offset[2];
        
        return 0;
    }
    return 1;
}

// Get accelerometer data
void MPU6050::getAccel(int16_t* accel_data)
{
    accel_data[0] = accel[0];
    accel_data[1] = accel[1];
    accel_data[2] = accel[2];
}

// Get gyroscope data
void MPU6050::getGyro(int16_t* gyro_data)
{
    gyro_data[0] = gyro[0];
    gyro_data[1] = gyro[1];
    gyro_data[2] = gyro[2];
}

// Get temperature
int MPU6050::getTemperature()
{
    uint8_t buffer[2];
    int16_t raw;
    float temp;
    
    IOI2C::readMultiBytesFromRegister(devAddr, MPU6050_RA_TEMP_OUT_H, 2, buffer);
    
    raw = (((int16_t)buffer[0]) << 8) | buffer[1];
    temp = 36.53 + ((float)raw) / 340;
    
    return (int)temp;
}

// Initialize gyroscope zero offset
void MPU6050::initGyroOffset()
{
    int i;
    int32_t sum[3] = {0};
    
    // Collect multiple samples and take average
    for (i = 0; i < 1000; i++) {
        getData();  // Get gyroscope data
        sum[0] += gyro[0];
        sum[1] += gyro[1];
        sum[2] += gyro[2];
        Delay::ms(2);
    }
    
    // Calculate zero offset
    gyro_offset[0] = sum[0] / 1000;
    gyro_offset[1] = sum[1] / 1000;
    gyro_offset[2] = sum[2] / 1000;
}


uint16_t MPU6050::dmpFeatureFlags = 0;
uint32_t MPU6050::msCounter = 0;
uint8_t MPU6050::dmpInitialize()
{
    uint8_t result;
    
    // 1. Initialize basic MPU6050 settings
    initialize();
    
    // Verify device ID
    if (getDeviceID() != 0x68) {
        return 1; // Device ID mismatch
    }
    
    // 2. Reset MPU6050
    writeByte(MPU6050_RA_PWR_MGMT_1, 0x80);
    Delay::ms(100);
    
    // 3. Wake up MPU6050
    writeByte(MPU6050_RA_PWR_MGMT_1, 0x00);
    
    // 4. Load DMP firmware
    for (uint16_t i = 0; i < dmpMemorySize; i += 16) {
        uint16_t size = (dmpMemorySize - i < 16) ? (dmpMemorySize - i) : 16;
        uint16_t addr = i / 16;
        
        result = writeDMPMemory(addr, size, &dmpMemory[i]);
        if (result != 0) {
            return result; // Write failed
        }
        Delay::ms(1); // Short delay
    }
    
    // 5. Configure DMP
    result = writeDMPConfigurationSet(dmpConfig, dmpConfigSize);
    if (result != 0) {
        return result;
    }
    
    // 6. Set DMP program start address
    writeByte(MPU6050_RA_BANK_SEL, 0);
    
    // 7. Enable DMP
    writeByte(MPU6050_RA_USER_CTRL, 0x80);
    
    // 8. Set default DMP features
    dmpFeatureFlags = DMP_FEATURE_6X_LP_QUAT | DMP_FEATURE_GYRO_CAL;
    enableDMPFeature(dmpFeatureFlags);
    
    // 9. Set default FIFO rate
    setDMPFifoRate(100); // 100Hz
    
    // 10. Initialize gyroscope offset
    initGyroOffset();
    
    return 0; // Success
}

// Set DMP FIFO rate
uint8_t MPU6050::setDMPFifoRate(uint16_t rate)
{
    // Calculate divider
    uint16_t div = 1000 / rate - 1;
    uint8_t data[2] = {(uint8_t)((div >> 8) & 0xFF), (uint8_t)(div & 0xFF)};
    
    return writeDMPMemory(0x02, 2, data);
}

// Get DMP FIFO rate
uint8_t MPU6050::getDMPFifoRate(uint16_t *rate)
{
    uint8_t data[2];
    uint8_t result = readDMPMemory(0x02, 2, data);
    
    if (result == 0) {
        uint16_t div = (data[0] << 8) | data[1];
        *rate = 1000 / (div + 1);
    }
    
    return result;
}

// Enable DMP features
uint8_t MPU6050::enableDMPFeature(uint16_t features)
{
    uint8_t result;
    
    // Enable low-power quaternion
    if (features & DMP_FEATURE_LP_QUAT) {
        result = enableLPQuaternion(1);
        if (result != 0) return result;
    }
    
    // Enable 6-axis quaternion
    if (features & DMP_FEATURE_6X_LP_QUAT) {
        result = enable6AxisQuaternion(1);
        if (result != 0) return result;
    }
    
    // Enable gyroscope auto calibration
    if (features & DMP_FEATURE_GYRO_CAL) {
        result = enableGyroCalibration(1);
        if (result != 0) return result;
    }
    
    // Store current feature state
    dmpFeatureFlags = features;
    
    // Configure FIFO
    writeByte(MPU6050_RA_FIFO_EN, 0x00);
    writeByte(MPU6050_RA_USER_CTRL, 0x40);  // Reset FIFO
    Delay::ms(50);
    writeByte(MPU6050_RA_USER_CTRL, 0x80);  // Enable DMP
    
    return 0;
}

// Get enabled DMP features
uint8_t MPU6050::getEnabledDMPFeatures(uint16_t *features)
{
    *features = dmpFeatureFlags;
    return 0;
}

// Set sensor orientation
uint8_t MPU6050::setDMPOrientation(uint16_t orient)
{
    // Convert to DMP-supported format
    uint8_t gyroOrientation[9] = {
        0x00, 0x00, 0x00,
        0x00, 0x00, 0x00,
        0x00, 0x00, 0x00
    };
    
    // Set orientation matrix based on the input orientation parameter
    switch (orient) {
        case ORIENT_PORTRAIT:
            gyroOrientation[0] = 1;
            gyroOrientation[4] = 1;
            gyroOrientation[8] = 1;
            break;
        case ORIENT_LANDSCAPE:
            gyroOrientation[1] = 1;
            gyroOrientation[3] = -1;
            gyroOrientation[8] = 1;
            break;
        case ORIENT_REVERSE_PORTRAIT:
            gyroOrientation[0] = -1;
            gyroOrientation[4] = -1;
            gyroOrientation[8] = 1;
            break;
        case ORIENT_REVERSE_LANDSCAPE:
            gyroOrientation[1] = -1;
            gyroOrientation[3] = 1;
            gyroOrientation[8] = 1;
            break;
    }
    
    // Write to DMP memory
    return writeDMPMemory(0xD0, 9, gyroOrientation);
}

// Enable low-power quaternion
uint8_t MPU6050::enableLPQuaternion(uint8_t enable)
{
    uint8_t data[4];
    uint8_t result = readDMPMemory(0x106, 4, data);
    if (result != 0) return result;
    
    if (enable)
        data[0] |= 0x01;
    else
        data[0] &= ~0x01;
    
    return writeDMPMemory(0x106, 4, data);
}

// Enable 6-axis quaternion
uint8_t MPU6050::enable6AxisQuaternion(uint8_t enable)
{
    uint8_t data[4];
    uint8_t result = readDMPMemory(0x112, 4, data);
    if (result != 0) return result;
    
    if (enable)
        data[2] |= 0x01;
    else
        data[2] &= ~0x01;
    
    return writeDMPMemory(0x112, 4, data);
}

// Enable gyroscope auto calibration
uint8_t MPU6050::enableGyroCalibration(uint8_t enable)
{
    // Gyroscope calibration register configuration
    uint8_t data[4] = {0xb8, 0xaa, 0xb3, 0x8d};
    uint8_t result;
    
    if (enable) {
        result = writeDMPConfigurationSet(data, 4);
    } else {
        // Disabling gyro calibration is omitted; requires DMP firmware-specific implementation
        result = 0;
    }
    
    return result;
}

// Set gyroscope zero bias
uint8_t MPU6050::setDMPGyroBias(int32_t *bias)
{
    uint8_t data[12];
    
    for (int i = 0; i < 3; i++) {
        // Convert to DMP format
        int32_t scaledBias = bias[i] * 0.98;
        data[i*4] = (uint8_t)((scaledBias >> 24) & 0xFF);
        data[i*4+1] = (uint8_t)((scaledBias >> 16) & 0xFF);
        data[i*4+2] = (uint8_t)((scaledBias >> 8) & 0xFF);
        data[i*4+3] = (uint8_t)(scaledBias & 0xFF);
    }
    
    return writeDMPMemory(0x8A, 12, data);
}

// Set accelerometer zero bias
uint8_t MPU6050::setDMPAccelBias(int32_t *bias)
{
    uint8_t data[12];
    int32_t accelBias[3];
    
    // Copy and adjust bias
    memcpy(accelBias, bias, 12);
    
    // Convert to DMP format
    for (int i = 0; i < 3; i++) {
        uint32_t mask = 1UL << 31;
        if (accelBias[i] < 0) {
            accelBias[i] = -accelBias[i];
            mask = 0;
        }
        accelBias[i] = accelBias[i] >> 3; // Divide by 8
        
        data[i*4] = (uint8_t)(((accelBias[i] >> 24) & 0x7F) | (mask >> 24));
        data[i*4+1] = (uint8_t)((accelBias[i] >> 16) & 0xFF);
        data[i*4+2] = (uint8_t)((accelBias[i] >> 8) & 0xFF);
        data[i*4+3] = (uint8_t)(accelBias[i] & 0xFF);
    }
    
    return writeDMPMemory(0x92, 12, data);
}

// Get pedometer step count
uint8_t MPU6050::getPedometerStepCount(uint32_t *count)
{
    uint8_t data[4];
    uint8_t result = readDMPMemory(0x0F0, 4, data);
    
    if (result == 0) {
        *count = ((uint32_t)data[0] << 24) | ((uint32_t)data[1] << 16) |
                 ((uint32_t)data[2] << 8) | data[3];
        
        // Update global variable
        MPU6050_StepCount = *count;
    }
    
    return result;
}

// Set pedometer step count
uint8_t MPU6050::setPedometerStepCount(uint32_t count)
{
    uint8_t data[4];
    
    data[0] = (uint8_t)((count >> 24) & 0xFF);
    data[1] = (uint8_t)((count >> 16) & 0xFF);
    data[2] = (uint8_t)((count >> 8) & 0xFF);
    data[3] = (uint8_t)(count & 0xFF);
    
    uint8_t result = writeDMPMemory(0x0F0, 4, data);
    
    // Update global variable
    if (result == 0) {
        MPU6050_StepCount = count;
    }
    
    return result;
}

// Get pedometer walk time
uint8_t MPU6050::getPedometerWalkTime(uint32_t *time)
{
    uint8_t data[4];
    uint8_t result = readDMPMemory(0x0F4, 4, data);
    
    if (result == 0) {
        *time = ((uint32_t)data[0] << 24) | ((uint32_t)data[1] << 16) |
                ((uint32_t)data[2] << 8) | data[3];
        
        // Update global variable
        MPU6050_WalkTime = *time;
    }
    
    return result;
}

// Set pedometer walk time
uint8_t MPU6050::setPedometerWalkTime(uint32_t time)
{
    uint8_t data[4];
    
    data[0] = (uint8_t)((time >> 24) & 0xFF);
    data[1] = (uint8_t)((time >> 16) & 0xFF);
    data[2] = (uint8_t)((time >> 8) & 0xFF);
    data[3] = (uint8_t)(time & 0xFF);
    
    uint8_t result = writeDMPMemory(0x0F4, 4, data);
    
    // Update global variable
    if (result == 0) {
        MPU6050_WalkTime = time;
    }
    
    return result;
}

// Read data packet from DMP FIFO
uint8_t MPU6050::readDMPFifoPacket(uint8_t *packet, uint16_t length)
{
    uint8_t fifoCount[2];
    uint16_t fifoSize;
    
    // Read FIFO count
    IOI2C::readMultiBytesFromRegister(devAddr, MPU6050_RA_FIFO_COUNT_H, 2, fifoCount);
    fifoSize = (fifoCount[0] << 8) | fifoCount[1];
    
    if (fifoSize < length) {
        return 1; // Not enough data in FIFO
    }
    
    // Read FIFO data
    return IOI2C::readMultiBytesFromRegister(devAddr, MPU6050_RA_FIFO_R_W, length, packet);
}

// Get millisecond timestamp
void MPU6050::getMs(uint32_t *time)
{
    // Simple timer, add 5ms per call (assuming MPU6050 interrupt cycle is 5ms)
    static uint32_t lastTime = 0;
    lastTime += 5;
    *time = lastTime;
    
    // NOTE: Use system clock in real applications
    // If using SysTick, you can get actual time from it
}

// Read data from DMP
uint8_t MPU6050::readDMPFifo(int16_t *gyro, int16_t *accel, int32_t *quat, 
                             uint32_t *timestamp, int16_t *sensors, uint8_t *more)
{
    uint8_t fifoBuffer[42]; // Enough to store a complete DMP packet
    uint8_t result;
    
    // Read the complete packet
    result = readDMPFifoPacket(fifoBuffer, 42);
    if (result != 0) {
        *more = 0;
        return result;
    }
    
    // Get timestamp
    getMs(timestamp);
    
    // Initialize sensor flags
    *sensors = 0;
    
    // Extract quaternion
    if (quat != NULL) {
        // Quaternion format: w, x, y, z
        quat[0] = ((int32_t)fifoBuffer[0] << 24) | ((int32_t)fifoBuffer[1] << 16) |
                  ((int32_t)fifoBuffer[2] << 8) | fifoBuffer[3];
        quat[1] = ((int32_t)fifoBuffer[4] << 24) | ((int32_t)fifoBuffer[5] << 16) |
                  ((int32_t)fifoBuffer[6] << 8) | fifoBuffer[7];
        quat[2] = ((int32_t)fifoBuffer[8] << 24) | ((int32_t)fifoBuffer[9] << 16) |
                  ((int32_t)fifoBuffer[10] << 8) | fifoBuffer[11];
        quat[3] = ((int32_t)fifoBuffer[12] << 24) | ((int32_t)fifoBuffer[13] << 16) |
                  ((int32_t)fifoBuffer[14] << 8) | fifoBuffer[15];
        
        // Update global quaternion
        for (int i = 0; i < 4; i++) {
            MPU6050_Quat[i] = quat[i];
        }
        
        // Convert quaternion to Euler angles
        float q0 = (float)quat[0] / 1073741824.0f;
        float q1 = (float)quat[1] / 1073741824.0f;
        float q2 = (float)quat[2] / 1073741824.0f;
        float q3 = (float)quat[3] / 1073741824.0f;
        
        // Calculate Euler angles
        MPU6050Data.roll = atan2(2.0f * (q0 * q1 + q2 * q3), 1.0f - 2.0f * (q1 * q1 + q2 * q2)) * 57.3f;
        MPU6050Data.pitch = asin(2.0f * (q0 * q2 - q3 * q1)) * 57.3f;
        MPU6050Data.yaw = atan2(2.0f * (q0 * q3 + q1 * q2), 1.0f - 2.0f * (q2 * q2 + q3 * q3)) * 57.3f;
        
        // Update global Euler angles
        Pitch = MPU6050Data.pitch;
        Roll = MPU6050Data.roll;
        Yaw = MPU6050Data.yaw;
        
        *sensors |= 0x01; // Quaternion data available
    }
    
    // Extract accelerometer data
    if (accel != NULL) {
        accel[0] = (fifoBuffer[28] << 8) | fifoBuffer[29];
        accel[1] = (fifoBuffer[32] << 8) | fifoBuffer[33];
        accel[2] = (fifoBuffer[36] << 8) | fifoBuffer[37];
        
        // Update global accel data
        for (int i = 0; i < 3; i++) {
            ::accel[i] = accel[i];
        }
        
        *sensors |= 0x02; // Accelerometer data available
    }
    
    // Extract gyroscope data
    if (gyro != NULL) {
        gyro[0] = (fifoBuffer[16] << 8) | fifoBuffer[17];
        gyro[1] = (fifoBuffer[20] << 8) | fifoBuffer[21];
        gyro[2] = (fifoBuffer[24] << 8) | fifoBuffer[25];
        
        // Update global gyro data
        for (int i = 0; i < 3; i++) {
            ::gyro[i] = gyro[i];
        }
        
        // Update balance control variables
        Gyro_Balance = gyro[0]; // Balance angular velocity
        Gyro_Turn = gyro[2];    // Turning angular velocity
        
        *sensors |= 0x04; // Gyroscope data available
    }
    
    // Check if more data remains in FIFO
    uint8_t fifoCount[2];
    IOI2C::readMultiBytesFromRegister(devAddr, MPU6050_RA_FIFO_COUNT_H, 2, fifoCount);
    *more = ((fifoCount[0] << 8) | fifoCount[1]) > 0;
    
    return 0; // Success
}

// DMP memory read/write functions
uint8_t MPU6050::writeDMPMemory(uint16_t memAddr, uint16_t length, const uint8_t *buffer)
{
    uint8_t result = 0;
    
    // Select bank
    writeByte(MPU6050_RA_BANK_SEL, memAddr >> 8);
    
    // Set starting address
    writeByte(MPU6050_RA_MEM_START_ADDR, memAddr & 0xFF);
    
    // Write data
    for (uint16_t i = 0; i < length; i++) {
        writeByte(MPU6050_RA_MEM_R_W, buffer[i]);
        
        // Optional: verify the write (increase reliability)
        uint8_t verify;
        result = readByte(MPU6050_RA_MEM_R_W);
        if (result != buffer[i]) {
            return 1; // Write failed
        }
    }
    
    return 0; // Success
}

uint8_t MPU6050::readDMPMemory(uint16_t memAddr, uint16_t length, uint8_t *buffer)
{
    // Select bank
    writeByte(MPU6050_RA_BANK_SEL, memAddr >> 8);
    
    // Set starting address
    writeByte(MPU6050_RA_MEM_START_ADDR, memAddr & 0xFF);
    
    // Read data
    for (uint16_t i = 0; i < length; i++) {
        buffer[i] = readByte(MPU6050_RA_MEM_R_W);
    }
    
    return 0; // Success
}

// Write DMP configuration set
uint8_t MPU6050::writeDMPConfigurationSet(const uint8_t *data, uint16_t size)
{
    uint8_t result;
    uint16_t i, j;
    
    for (i = 0; i < size;) {
        uint8_t bank = data[i++];
        uint8_t address = data[i++];
        uint8_t length = data[i++];
        
        // Validate configuration data
        if (length > 0) {
            // Write data
            result = writeDMPMemory((bank << 8) | address, length, &data[i]);
            if (result != 0) {
                return result; // Write failed
            }
        }
        
        i += length;
    }
    
    return 0; // Success
}

// Rewritten getDMPData function with new reading mechanism
uint8_t MPU6050::getDMPData()
{
    int16_t gyroData[3];
    int16_t accelData[3];
    int32_t quatData[4];
    uint32_t timestamp;
    int16_t sensors;
    uint8_t more;
    
    // Read data from DMP FIFO
    uint8_t result = readDMPFifo(gyroData, accelData, quatData, &timestamp, &sensors, &more);
    
    // No need to recalculate, global variables are already updated in readDMPFifo
    
    return result;
}

// Enhanced dmpInit function
void MPU6050::dmpInit()
{
    // Call enhanced initialization
    if (dmpInitialize() != 0) {
        // Initialization failed, reset system
        if (Flag_Show == 1) {
            NVIC_SystemReset();
        }
    }
    
    // Enable DMP interrupt
    writeByte(MPU6050_RA_INT_ENABLE, 0x02);
    
    // Set initialization flag
    Flag_Show = 1;
}


